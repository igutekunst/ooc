.TH "class_header" 3 "Fri Sep 27 2019" "Object-Oriented-C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
class_header
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <object_internal\&.h>\fP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "unsigned long \fBmagic\fP"
.br
.ti -1c
.RI "size_t \fBsize\fP"
.br
.ti -1c
.RI "size_t(* \fBget_size\fP )(const void *_self)"
.br
.ti -1c
.RI "size_t(* \fBget_len\fP )(const void *_self)"
.br
.ti -1c
.RI "const void *(* \fBobject_init\fP )(const void *_self, va_list args)"
.br
.ti -1c
.RI "void(* \fBobject_deinit\fP )(const void *_self)"
.br
.ti -1c
.RI "void(* \fBprint\fP )(const void *_self)"
.br
.ti -1c
.RI "const char *(* \fBstr\fP )(const void *_self)"
.br
.ti -1c
.RI "void *(* \fBto_String\fP )(const void *_self)"
.br
.ti -1c
.RI "const void *(* \fBappend\fP )(const void *_self, const void *_other)"
.br
.ti -1c
.RI "bool(* \fBequals\fP )(const void *_self, const void *_other)"
.br
.ti -1c
.RI "const void *(* \fBiter\fP )(const void *_object)"
.br
.ti -1c
.RI "const void *(* \fBcopy\fP )(const void *_self)"
.br
.ti -1c
.RI "void(* \fBinsert\fP )(const void *_self, const void *_key, const void *item)"
.br
.ti -1c
.RI "const void *(* \fBget\fP )(const void *_self, const void *_key)"
.br
.ti -1c
.RI "void(* \fBdel_item\fP )(const void *_self, const void *key)"
.br
.ti -1c
.RI "uint64_t(* \fBhash\fP )(const void *_self)"
.br
.ti -1c
.RI "const void *(* \fBnext\fP )(const void *_self)"
.br
.ti -1c
.RI "const char * \fBobject_name\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
All ooc classes have a \fBclass_header\fP\&.
.PP
The header provides function pointers to implementations of all supported methods for a given class\&.
.PP
Each object (instantiation of a class) has a pointer to the per-class \fBclass_header\fP\&.
.PP
A minimum class must at least provide implementations for magic, size, object_init, object_deinit and object_name 
.PP
Definition at line 21 of file object_internal\&.h\&.
.SH "Field Documentation"
.PP 
.SS "const void*(* class_header::append) (const void *_self, const void *_other)"
Implement to enable appending items to an class\&. If an class supports appending, it should probably support either get, or iteration\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc container object 
.br
\fI_other\fP ooc object supported by container 
.RE
.PP

.PP
Definition at line 101 of file object_internal\&.h\&.
.PP
Referenced by append()\&.
.SS "const void*(* class_header::copy) (const void *_self)"
Copy an ooc object\&.
.PP
Implement functionality to copy an object\&. The expectation is that it is deep copy\&. Perhaps there should be a convention for shallow copies
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of _self 
.RE
.PP

.PP
Definition at line 134 of file object_internal\&.h\&.
.PP
Referenced by copy()\&.
.SS "void(* class_header::del_item) (const void *_self, const void *key)"
Implement to enabled indexed deletion from a collection\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.br
\fIkey\fP key to delete 
.RE
.PP

.PP
Definition at line 172 of file object_internal\&.h\&.
.SS "bool(* class_header::equals) (const void *_self, const void *_other)"
Implement to allow objects to be compared with a custom function\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP 
.br
\fI_other\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
true if objects are equal\&. If not implemented, equals will compare pointers 
.RE
.PP

.PP
Definition at line 112 of file object_internal\&.h\&.
.SS "const void*(* class_header::get) (const void *_self, const void *_key)"
Implement to enable indexed access\&. value = get(collection, key) value = collection[key]
.PP
Typically, key must be in collection, or this function should exit early with an error\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.br
\fI_key\fP ooc object key 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 162 of file object_internal\&.h\&.
.SS "size_t(* class_header::get_len) (const void *_self)"
Get number of items in container object 
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.RE
.PP
\fBReturns:\fP
.RS 4
number of items in container 
.RE
.PP

.PP
Definition at line 37 of file object_internal\&.h\&.
.PP
Referenced by len()\&.
.SS "size_t(* class_header::get_size) (const void *_self)"
Get size of object in bytes 
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.RE
.PP
\fBReturns:\fP
.RS 4
size in bytes 
.RE
.PP

.PP
Definition at line 30 of file object_internal\&.h\&.
.PP
Referenced by size()\&.
.SS "uint64_t(* class_header::hash) (const void *_self)"
Implement to enable storing in a hash table\&.
.PP
Note: as of now, HashTables will also use \fBequals()\fP to confirm keys are unique\&. If hash is not implemented, as of now, the HashTable does not support it\&. This may change in the future\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.RE
.PP
\fBReturns:\fP
.RS 4
64 bit user defined hash 
.RE
.PP

.PP
Definition at line 189 of file object_internal\&.h\&.
.PP
Referenced by del_item_HashMap(), get_HashMap(), insert_HashMap(), and internal_insert_HashMap()\&.
.SS "void(* class_header::insert) (const void *_self, const void *_key, const void *item)"
Implement to enable indexed assignment\&. insert(collection, key, value) is equivalent to collection[key] = value
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.br
\fI_key\fP ooc object key to index into collection 
.br
\fIitem\fP value to store at given index 
.RE
.PP

.PP
Definition at line 145 of file object_internal\&.h\&.
.SS "const void*(* class_header::iter) (const void *_object)"
Return an iterator to support iteration\&. 
.PP
\fBParameters:\fP
.RS 4
\fI_object\fP ooc object 
.RE
.PP
\fBReturns:\fP
.RS 4
ooc iterator 
.RE
.PP

.PP
Definition at line 122 of file object_internal\&.h\&.
.SS "unsigned long class_header::magic"

.PP
Definition at line 22 of file object_internal\&.h\&.
.SS "const void*(* class_header::next) (const void *_self)"
Implement to support iteration\&. You must implement \fBiter()\fP and \fBnext()\fP to support iteration\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP iterable returned from \fBiter()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
next item in iteration\&. 
.RE
.PP

.PP
Definition at line 199 of file object_internal\&.h\&.
.SS "void(* class_header::object_deinit) (const void *_self)"
De-initialize and free resources used by _self\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.RE
.PP

.PP
Definition at line 59 of file object_internal\&.h\&.
.PP
Referenced by del()\&.
.SS "const void*(* class_header::object_init) (const void *_self, va_list args)"
Create and initialize an object Technically, _self needs to be the full class header for a concrete type, which starts with a \fBclass_header\fP, followed by class specific fields\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc class like \fBString\fP or \fBHashMap\fP\&. 
.br
\fIargs\fP arguments to initialize object\&. Varies based on class type 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 49 of file object_internal\&.h\&.
.SS "const char* class_header::object_name"
Object name as C string 
.PP
Definition at line 204 of file object_internal\&.h\&.
.PP
Referenced by clsname()\&.
.SS "void(* class_header::print) (const void *_self)"
Print and object to stdout 
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.RE
.PP

.PP
Definition at line 65 of file object_internal\&.h\&.
.PP
Referenced by print()\&.
.SS "size_t class_header::size"

.PP
Definition at line 23 of file object_internal\&.h\&.
.SS "const char*(* class_header::str) (const void *_self)"
Return the c string (char*) representation of an object
.PP
May be used by to_String to make an ooc \fBString\fP representation\&. Usually it's not necessary to implement to_String separately\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc object 
.RE
.PP
\fBReturns:\fP
.RS 4
c string representation 
.RE
.PP

.PP
Definition at line 78 of file object_internal\&.h\&.
.PP
Referenced by str()\&.
.SS "void*(* class_header::to_String) (const void *_self)"
Return \fBString\fP representation of object\&.
.PP
May allocate a new \fBString\fP object, and may or may not return a different \fBString\fP object each time\&.
.PP
Usually it is sufficient to implement str\&.
.PP
\fBParameters:\fP
.RS 4
\fI_self\fP ooc objet 
.RE
.PP
\fBReturns:\fP
.RS 4
ooc \fBString\fP object 
.RE
.PP

.PP
Definition at line 91 of file object_internal\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Object-Oriented-C from the source code\&.
